// graph: polymorphic types

// List[T] <: Iterable[T]

// TODO: look into abstracting type parameters into type fields, and being able
// to instansiate a library

// keywords: associated types, materials and shapes

type GNode[E] = {
    edges(self: Self) : Iterable[E]
}

type GEdge[N] = {
    src(self: Self) : N
    dst(self: Self) : N
}


type Graph[N, E] = (N <: GNode[E]) & (E <: GEdge[N])

type Container[V] = {
    val(self: Self) : V
}

type Equal[V] = {
    equals(v1: V, v2: V) : Bool
}

class LT {}
class EQ {}
class GT {}

type Order = LT | EQ | GT

type Comparable[V] = {
    compare(v1: V, v2: V) : Order
}


type ValueGraph[V, N, E] = Graph[N, E] & (N < Container[V])

searchGraph[V, N, E](n : N, v : V) : Option[N]
    where ValueGraph[V, N, E] & (V <: Equal[V]) & (N <: Comparable[N])
{
    let visited = Set[N]::create();
    let pending = Queue[N]::create({n});

    while (!pending.empty()) {
        let next = pending.dequeue();

        if (!visited.contains(next)) {
            visited.add(next);
            if (next.val() == v) {
                Some(next)
            }
            else {
                for (edge : next.edges()) {
                    pending.enqueue(edge.dst());
                }
            }
        }
    }

    None
}


class Node[V] {
    var v : V

    var edges : List[Edge[Node[V]]]
    edges(self: Self) : Iterable[Edge[Node[V]]] {
        self.edges
    }
    compare(self: Self, other: Self) : Ord {
        ... // use addressOf?
    }
}


class Edge[N] {
    var start : N
    var end : N
    src(self: Self) : N { self.start }
    dst(self: Self) : N { self.end }
}


// TODO try to typecheck in compiler
// TODO try to typecheck by hand